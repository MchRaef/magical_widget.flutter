// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'first_page_bloc.dart';

// **************************************************************************
// MagicalWidgetGenerator
// **************************************************************************

// This code is autogenerated for you by the magical_widget package
// For all inquiry, please contact the author: Raef Mousheimish <mch.raef@gmail.com>
// *****************************************************************************

/// ********* DOC GENERATED BY MAGICAL WIDGET LIBRARY **********
/// This is the generated enum that will be used as the control for your UI widgets, you can use these control for any widget as you wish
/// This is enum will start with MAGICAL_ then the name of your original enum will be appended
/// The elements of this enum will be used by the users to select which contol to change
/// *************************************************************

enum MAGICAL_firstPageControls {
  txtField1Input,
  enableFirstBtn,
  enableSecondBtn,
  txtField2Input,
}

/// ********* DOC GENERATED BY MAGICAL WIDGET LIBRARY **********
/// This is a generated class that will hold the controls for your UI
/// This class is always named [MagicalController]
/// This is going to be the class of the stream
/// *************************************************************

class MagicalController {
  String txtField1Input;
  bool enableFirstBtn;
  bool enableSecondBtn;
  String txtField2Input;
  MagicalController({
    this.txtField1Input = "",
    this.enableFirstBtn = true,
    this.enableSecondBtn = false,
    this.txtField2Input = "Magic",
  });
  MagicalController.fromOld(MagicalController old) {
    this.txtField1Input = old.txtField1Input;
    this.enableFirstBtn = old.enableFirstBtn;
    this.enableSecondBtn = old.enableSecondBtn;
    this.txtField2Input = old.txtField2Input;
  }
  factory MagicalController.setValues(MagicalController old,
      List<MAGICAL_firstPageControls> configs, List<dynamic> values) {
    var uiConfig = MagicalController.fromOld(old);
    for (var pair in zip([configs, values])) {
      uiConfig = MagicalController.setValue(uiConfig, [pair[0]], pair[1]);
    }
    return uiConfig;
  }

  factory MagicalController.setValue(MagicalController old,
      List<MAGICAL_firstPageControls> configs, dynamic value) {
    var uiConfig = MagicalController.fromOld(old);
    for (var config in configs) {
      uiConfig = _handleUIConfigs(config, uiConfig, value: value);
    }
    return uiConfig;
  }

  static MagicalController _handleUIConfigs(
      MAGICAL_firstPageControls config, MagicalController uiConfig,
      {dynamic value}) {
    switch (config) {
      case MAGICAL_firstPageControls.txtField1Input:
        uiConfig.txtField1Input = value;
        break;

      case MAGICAL_firstPageControls.enableFirstBtn:
        uiConfig.enableFirstBtn = value;
        break;

      case MAGICAL_firstPageControls.enableSecondBtn:
        uiConfig.enableSecondBtn = value;
        break;

      case MAGICAL_firstPageControls.txtField2Input:
        uiConfig.txtField2Input = value;
        break;

      default:
    }
    return uiConfig;
  }
}

/// ********* DOC GENERATED BY MAGICAL WIDGET LIBRARY **********
/// This is a generated bloc class that holds the logic of changing the controls
/// It makes sure that only the targeted widget is changed and all other components remain inteact
/// The bloc contains a _dispose_ method to close the subjects generated within this class.
/// The class is always [MagicalBloc]
/// The fields that the user will use within this class are:
/// - __magicalStream__ to refer to the stream
/// - __magicalValue__ to refer to the current value of the stream
/// *************************************************************

class MagicalBloc {
  MagicalBloc() {
    firstLoad();
  }
  final _magicalSubject = BehaviorSubject<MagicalController>();
  Stream<MagicalController> get magicalStream => _magicalSubject.stream;
  Function(MagicalController) get _magicalAdd => _magicalSubject.sink.add;
  void magicalAddEventToStream(event) => _magicalAdd(event);
  MagicalController get magicalValue => _magicalSubject.value;

  Future dispose() async {
    _magicalSubject.close();
  }

  firstLoad() {
    magicalAddEventToStream(MagicalController());
  }

  /// ********* DOC GENERATED BY MAGICAL WIDGET LIBRARY **********
  /// This is the main method to use in order to change a set of value for a set of controls
  /// [values] is a list of new values that you want to submit for the specific controls
  /// [configs] is a list of the controls that you want to change. They are all elements from the generated enum that starts with MAGICAL_
  /// The ith element in values should correspond to the ith element in configs: That is, first in values to first in configs, second in values to second in configs, and so on
  /// *************************************************************

  changeUIElements(values, configs) {
    magicalAddEventToStream(
        MagicalController.setValues(magicalValue, configs, values));
  }

  /// ********* DOC GENERATED BY MAGICAL WIDGET LIBRARY **********
  /// This is the main method to use in order to change the value of a control
  /// [value] is the new value that you want to submit for the specific control
  /// [config] is the control that you want to change. It is an element from the generated enum that starts with MAGICAL_
  /// *************************************************************

  changeUIElement(value, config) {
    magicalAddEventToStream(
        MagicalController.setValue(magicalValue, [config], value));
  }
}

/// ********* DOC GENERATED BY MAGICAL WIDGET LIBRARY **********
/// By default the withProvider of the [Alakazam] annotation is set to true.
/// This will generate the [MagicalWidget] class. This widget is an inherited widget and it holds the generated bloc, which it returns from its _of()_ method
/// If you do not want this behavior, the withProvider argument could be set to false, and this widget will not be generated
/// *************************************************************

class MagicalWidget extends InheritedWidget {
  final MagicalBloc magicalBloc = MagicalBloc();
  MagicalWidget({
    Key key,
    @required Widget child,
  })  : assert(child != null),
        super(key: key, child: child);

  static MagicalBloc of(BuildContext context) {
    return (context.inheritFromWidgetOfExactType(MagicalWidget)
            as MagicalWidget)
        .magicalBloc;
  }

  @override
  bool updateShouldNotify(MagicalWidget old) {
    return old.magicalBloc != magicalBloc;
  }
}
